package com.nickrobison.trestle.gaulintegrator;

import com.nickrobison.trestle.reasoner.exceptions.TrestleMissingIndividualException;
import com.nickrobison.trestle.datasets.GAULObject;
import com.nickrobison.trestle.reasoner.TrestleBuilder;
import com.nickrobison.trestle.reasoner.TrestleReasoner;
import com.nickrobison.trestle.types.TrestleIndividual;
import com.nickrobison.trestle.types.TrestleRelation;
import me.tongfei.progressbar.ProgressBar;
import org.apache.hadoop.conf.Configuration;
import org.checkerframework.checker.initialization.qual.UnderInitialization;
import org.semanticweb.owlapi.model.IRI;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings({"squid:S106"}) // We can ignore this, using the system printer is fine.
/**
 * The evaluator takes a list of objects generated by {@link GAULReducer} and looks for any 'orphaned objects'
 * meaning, those that do not exist for the entire duration of the analysis window, but are not part of a corresponding SPLIT/MERGE
 */
public class IntegrationEvaluator {

    private static final Pattern codeNameRegex = Pattern.compile("([0-9]+)-(.*)");

    private final TrestleReasoner reasoner;
    private final String filePath;


    IntegrationEvaluator(String filePath) {
        this.reasoner = setupReasoner();
        this.filePath = filePath;
    }


    public void evaluateAlgorithm() throws IOException {
//        Read in the input file
        final FileInputStream inputStream = new FileInputStream(new File(this.filePath));
        final BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        Queue<AlgorithmResult> results = new ArrayDeque<>();
        try {
            String line;
            while ((line = br.readLine()) != null) {
//                Split the columns (\t)
                final String[] splitLine = line.split("\t");

//                Split the 2nd column into its pieces
                final String[] resultSplit = splitLine[1].split(":");

//                Split the adm2 code/name
                final Matcher matchedCodeName = codeNameRegex.matcher(resultSplit[2]);
                if (!matchedCodeName.matches()) {
                    throw new IllegalStateException("Cannot match with Regex!");
                }

//                Create the new record
                try {
                    final AlgorithmResult result = new AlgorithmResult(
                            Integer.parseInt(resultSplit[0]),
                            resultSplit[1],
                            Integer.parseInt(matchedCodeName.group(1)),
                            matchedCodeName.group(2),
                            LocalDate.parse(resultSplit[3]),
                            LocalDate.parse(resultSplit[4]));
                    results.add(result);
                } catch (ArrayIndexOutOfBoundsException e) {
                    System.out.println(splitLine[1]);
                }

            }
        } finally {
            inputStream.close();
            br.close();
        }

//        Create a progress base
        Set<AlgorithmResult> orphanedResults;
        try (ProgressBar pb = new ProgressBar("Analyzing Individuals:", results.size())) {

//        Now, process the results

            orphanedResults = new HashSet<>();
            Set<TrestleIndividual> orphanedIndividuals = new HashSet<>();

            for (AlgorithmResult result : results) {
                try {
                    final TrestleIndividual trestleIndividual = this.reasoner.getTrestleIndividual(result.getID()).blockingGet();
                    final Optional<String> anyRelation = trestleIndividual.getRelations()
                            .stream()
                            .map(TrestleRelation::getType)
    //                    Split Filter
                            .filter(relation -> (relation.contains("SPLIT") || relation.contains("MERGE")))
                            .findAny();
                    if (!anyRelation.isPresent()) {
                        orphanedResults.add(result);
                        orphanedIndividuals.add(trestleIndividual);
                    }
                } catch (TrestleMissingIndividualException e) {
                    System.err.println(String.format("Could not find %s", e.getIndividual()));
    //                Just don't fail
                }
                pb.step();
            }
        }

        System.out.println(String.format("========== (%s) Orphaned ADM2 Entities=======", orphanedResults.size()));
        orphanedResults
                .stream()
                .sorted(Comparator.comparing(AlgorithmResult::getAdm0Code)
                        .thenComparing(AlgorithmResult::getAdm2Name))
                .forEach(result -> System.out.println(result.getID()));
    }


    private TrestleReasoner setupReasoner(@UnderInitialization IntegrationEvaluator this) {
//        Read in the conf
        Configuration conf = new Configuration();

        final Properties userProperties = new Properties();
        final InputStream is = IntegrationRunner.class.getClassLoader().getResourceAsStream("sd.properties");
        try {
            userProperties.load(is);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }

        for (String name : userProperties.stringPropertyNames()) {
            conf.set(name, userProperties.getProperty(name));
        }


        return new TrestleBuilder()
                .withDBConnection(conf.get("reasoner.db.connection"),
                        conf.get("reasoner.db.username"),
                        conf.get("reasoner.db.password"))
                .withInputClasses(GAULObject.class)
                .withOntology(IRI.create(conf.get("reasoner.ontology.location")))
                .withPrefix(conf.get("reasoner.ontology.prefix"))
                .withName(conf.get("reasoner.ontology.name"))
                .withoutCaching()
                .withoutMetrics()
                .build();
    }

    public void shutdown() {
        this.reasoner.shutdown(false);
    }


    public static void main(String[] args) throws IOException {
        final IntegrationEvaluator evaluator = new IntegrationEvaluator(args[0]);
        try {
            evaluator.evaluateAlgorithm();
            System.exit(0);
        } finally {
            evaluator.shutdown();
        }
    }

    private static class AlgorithmResult {

        private final int adm0Code;
        private final String adm0Name;
        private final int adm2Code;
        private final String adm2Name;
        private final LocalDate start;
        private final LocalDate end;

        public AlgorithmResult(int adm0Code, String adm0Name, int adm2Code, String adm2Name, LocalDate start, LocalDate end) {
            this.adm0Code = adm0Code;
            this.adm0Name = adm0Name;
            this.adm2Code = adm2Code;
            this.adm2Name = adm2Name;
            this.start = start;
            this.end = end;
        }

        public int getAdm0Code() {
            return adm0Code;
        }

        public String getAdm0Name() {
            return adm0Name;
        }

        public int getAdm2Code() {
            return adm2Code;
        }

        public String getAdm2Name() {
            return adm2Name;
        }

        public LocalDate getStart() {
            return start;
        }

        public LocalDate getEnd() {
            return end;
        }

        public String getID() {
            return String.format("%s-%s-%s-%s", getAdm2Code(), getAdm2Name(), getStart().getYear(), getEnd().getYear());
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            AlgorithmResult that = (AlgorithmResult) o;

            if (adm0Code != that.adm0Code) return false;
            if (adm2Code != that.adm2Code) return false;
            if (!adm0Name.equals(that.adm0Name)) return false;
            if (!adm2Name.equals(that.adm2Name)) return false;
            if (!start.equals(that.start)) return false;
            return end.equals(that.end);
        }

        @Override
        public int hashCode() {
            int result = adm0Code;
            result = 31 * result + adm0Name.hashCode();
            result = 31 * result + adm2Code;
            result = 31 * result + adm2Name.hashCode();
            result = 31 * result + start.hashCode();
            result = 31 * result + end.hashCode();
            return result;
        }
    }
}
